-- ============================================================
--  Pixel Blade Script v3.0 | Fixed & Optimized
--  Fixes: Rayfield init, request() compat, nil checks,
--         remote guards, ESP cleanup, loop stability,
--         webhook error handling, executor compatibility
-- ============================================================

-- SERVICES
local RS = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local WS = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

local LP = Players.LocalPlayer

-- ============================================================
-- ORION UI INIT
-- ============================================================
local OrionLib = loadstring(game:HttpGet(
    "https://raw.githubusercontent.com/shlexware/Orion/main/source"
))()

local Window = OrionLib:MakeWindow({
    Name         = "Pixel Blade | v3.0",
    HidePremium  = false,
    SaveConfig   = true,
    ConfigFolder = "PixelBlade",
    IntroEnabled = true,
    IntroText    = "Pixel Blade",
})

-- ============================================================
-- REMOTES (safe waiting with fallback)
-- ============================================================
local Remotes = RS:FindFirstChild("remotes") or RS:WaitForChild("remotes", 10)

local function GetRemote(name, timeout)
    if not Remotes then return nil end
    return Remotes:FindFirstChild(name) or Remotes:WaitForChild(name, timeout or 5)
end

local SwingEvent     = GetRemote("swing")
local HitEvent       = GetRemote("onHit")
local ProjectileEvent = GetRemote("projectileSpawn")

-- ============================================================
-- SETTINGS
-- ============================================================
getgenv().S = getgenv().S or {
    -- Combat
    KillAura    = false,
    AuraRange   = 20,
    AttackSpeed = 0.1,
    TeamCheck   = true,
    WallCheck   = false,
    Priority    = "Closest",
    TargetPlayers = true,
    TargetNPCs    = true,

    -- Boss
    BossAttack = false,
    BossName   = "Atticus",
    BossSpeed  = 0.1,

    -- Movement
    Speed      = false,
    WalkSpeed  = 16,
    Jump       = false,
    JumpPower  = 50,

    -- Auto TP
    AutoTP      = false,
    TPRange     = 30,
    TPWallCheck = true,

    -- Farm
    AutoFarm   = false,
    FarmRadius = 50,

    -- Collect
    AutoCollect  = false,
    CollectRadius = 50,
    CollectDelay  = 0.15,

    -- Dodge
    AutoDodge   = false,
    DodgeMethod = "Teleport",

    -- ESP
    ESP      = false,
    ESPColor = Color3.fromRGB(255, 0, 0),

    -- Webhook
    WebhookURL     = "",
    WebhookEnabled = false,

    -- Misc
    AutoClaim   = true,
    AutoRespawn = true,
}

local S = getgenv().S

-- ============================================================
-- EXECUTOR-COMPATIBLE HTTP REQUEST
-- Fix: original used bare `request()` which not all executors support
-- ============================================================
local function HttpRequest(opts)
    -- Try common executor HTTP APIs in order of preference
    local fn = (syn and syn.request)
        or (http and http.request)
        or (http_request)
        or (request)
        or nil

    if not fn then
        warn("[Webhook] No HTTP function found in this executor.")
        return nil, "no_http"
    end

    local ok, res = pcall(fn, opts)
    if not ok then
        warn("[Webhook] HTTP request failed: " .. tostring(res))
        return nil, res
    end
    return res
end

-- ============================================================
-- WEBHOOK SYSTEM
-- ============================================================
local function SendWebhook(title, description, color)
    if not S.WebhookEnabled or S.WebhookURL == "" then return false end

    local payload = HttpService:JSONEncode({
        embeds = {{
            title       = tostring(title),
            description = tostring(description),
            color       = color or 16711680,
            footer      = { text = "Pixel Blade v3.0 | " .. os.date("%X") },
        }}
    })

    local res, err = HttpRequest({
        Url     = S.WebhookURL,
        Method  = "POST",
        Headers = { ["Content-Type"] = "application/json" },
        Body    = payload,
    })

    if not res then return false end
    -- Discord returns 204 on success
    return (res.StatusCode == 204 or res.StatusCode == 200)
end

local function WebhookNotify(event, details)
    if not details then details = {} end
    if event == "BossKilled" then
        SendWebhook("Boss Defeated",
            "**Boss:** " .. tostring(details.name or "?") ..
            "\n**Time:** " .. tostring(details.time or "?") .. "s", 65280)
    elseif event == "PlayerKilled" then
        SendWebhook("Player Eliminated",
            "**Player:** " .. tostring(details.name or "?"), 16776960)
    elseif event == "LevelUp" then
        SendWebhook("Level Up!",
            "**New Level:** " .. tostring(details.level or "?"), 65535)
    elseif event == "ScriptStarted" then
        SendWebhook("Script Started",
            "**User:** " .. LP.Name .. "\n**Features Active**", 3447003)
    end
end

-- ============================================================
-- BOSS DATABASE
-- ============================================================
local Bosses = {
    Atticus = { name = "Atticus",  damage = 72, useDebug = false },
    Maneater = { name = "Humanoid", damage = 64, useDebug = true, debugId = "1_851039" },
}

-- ============================================================
-- CODES
-- ============================================================
local Codes = {
    "BREAKABLES", "AncientSands", "PLUSHIE", "625K", "CrimsonNightmare",
    "600K", "575K", "550K", "FREEWISH", "World4", "525K", "Rings",
    "Alpha", "Theo", "FBG",
}

-- ============================================================
-- UTILITY
-- ============================================================

-- Safe remote fire: handles any number of args cleanly
local function SafeFire(remote, ...)
    if not remote or not remote.Parent then return false end
    return pcall(remote.FireServer, remote, ...)
end

-- Safe remote invoke
local function SafeInvoke(remote, ...)
    if not remote or not remote.Parent then return false end
    return pcall(remote.InvokeServer, remote, ...)
end

-- getnilinstances with executor fallback
local function GetNilInstances()
    if getnilinstances then
        return getnilinstances()
    end
    return {}
end

local function GetNil(name, id)
    for _, obj in ipairs(GetNilInstances()) do
        if obj.Name == name then
            local ok, dbgId = pcall(function() return obj:GetDebugId() end)
            if ok and dbgId == id then
                return obj
            end
        end
    end
end

local function IsAlly(hum)
    if not S.TeamCheck or not hum then return false end
    local p = Players:GetPlayerFromCharacter(hum.Parent)
    return p and LP.Team and p.Team == LP.Team
end

-- Wall check (respects per-feature flags)
local function HasWall(from, to, useTPCheck)
    local flag = useTPCheck and S.TPWallCheck or S.WallCheck
    if not flag then return false end

    local char = LP.Character
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = char and { char } or {}

    local dir = to - from
    local result = WS:Raycast(from, dir, params)
    if not result then return false end

    local inst = result.Instance
    if inst.Transparency >= 0.9 then return false end

    local parent = inst.Parent
    if parent then
        if parent:FindFirstChildOfClass("Humanoid") then return false end
        if parent.Name == "Mobs" then return false end
    end

    return true
end

-- ============================================================
-- TARGET CACHE (optimized, no freeze)
-- ============================================================
local Cache    = {}
local LastCache = 0
local MAX_TARGETS = 50

local function UpdateCache()
    if tick() - LastCache < 0.5 then return end

    local newCache = {}
    local count    = 0
    local iter     = 0

    for _, model in ipairs(WS:GetChildren()) do
        if count >= MAX_TARGETS then break end

        iter = iter + 1
        if iter % 15 == 0 then task.wait() end -- yield to prevent freeze

        if model:IsA("Model") then
            local hum  = model:FindFirstChildOfClass("Humanoid")
            local root = model:FindFirstChild("HumanoidRootPart") or model.PrimaryPart

            if hum and hum.Health > 0 and root then
                table.insert(newCache, {
                    hum      = hum,
                    root     = root,
                    model    = model,
                    isPlayer = Players:GetPlayerFromCharacter(model) ~= nil,
                })
                count = count + 1
            end
        end
    end

    Cache     = newCache
    LastCache = tick()
end

local function GetTarget()
    local char = LP.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return nil end

    local targets  = {}
    local rootPos  = root.Position
    local checked  = 0

    for _, t in ipairs(Cache) do
        if checked >= 25 then break end

        -- Validate target is still alive and exists
        if t.hum and t.hum.Parent and t.hum.Health > 0
            and t.root and t.root.Parent
            and t.model ~= char then

            if not IsAlly(t.hum) then
                if (t.isPlayer and S.TargetPlayers) or (not t.isPlayer and S.TargetNPCs) then
                    local dist = (rootPos - t.root.Position).Magnitude

                    if dist <= S.AuraRange then
                        table.insert(targets, {
                            hum   = t.hum,
                            root  = t.root,
                            model = t.model,
                            dist  = dist,
                            hp    = t.hum.Health,
                        })
                    end

                    checked = checked + 1
                end
            end
        end
    end

    if #targets == 0 then return nil end

    if S.Priority == "Closest" then
        table.sort(targets, function(a, b) return a.dist < b.dist end)
    elseif S.Priority == "Lowest Health" then
        table.sort(targets, function(a, b) return a.hp < b.hp end)
    else
        table.sort(targets, function(a, b) return a.hp > b.hp end)
    end

    for _, t in ipairs(targets) do
        if not HasWall(rootPos, t.root.Position, false) then
            return t
        end
    end

    return nil
end

-- ============================================================
-- BOSS SYSTEM
-- ============================================================
local BossCache = nil
local LastBoss  = 0

local function GetBoss()
    if tick() - LastBoss < 1 then return BossCache end

    local boss = Bosses[S.BossName]
    if not boss then
        BossCache = nil
        LastBoss  = tick()
        return nil
    end

    local hum = nil

    if boss.useDebug and boss.debugId then
        hum = GetNil(boss.name, boss.debugId)
    end

    if not hum then
        local model = WS:FindFirstChild(boss.name)
        hum = model and model:FindFirstChildOfClass("Humanoid")
    end

    if hum and hum.Parent and hum.Health > 0 then
        local root = hum.Parent:FindFirstChild("HumanoidRootPart") or hum.Parent.PrimaryPart
        BossCache  = { hum = hum, root = root, dmg = boss.damage }
    else
        BossCache = nil
    end

    LastBoss = tick()
    return BossCache
end

-- ============================================================
-- COMBAT
-- ============================================================
local LastAtk = 0

local function Attack(target, dmg)
    if not target then return end
    if not target.hum or not target.hum.Parent then return end
    if target.hum.Health <= 0 then return end
    if tick() - LastAtk < S.AttackSpeed then return end

    SafeFire(SwingEvent)
    SafeFire(HitEvent, target.hum, dmg or 64, {}, 0)
    LastAtk = tick()
end

-- ============================================================
-- AUTO DODGE
-- ============================================================
local LastDodge = 0

local function Dodge()
    if tick() - LastDodge < 0.3 then return end

    local char = LP.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    local hum  = char and char:FindFirstChildOfClass("Humanoid")
    if not root or not hum then return end

    local angles = {45, -45, 90, -90, 135, -135, 180}
    local angle  = math.rad(angles[math.random(#angles)])
    local dir    = Vector3.new(math.cos(angle), 0, math.sin(angle))
    local pos    = root.Position + (dir * 12)

    if S.DodgeMethod == "Teleport" or S.DodgeMethod == "Both" then
        pcall(function() root.CFrame = CFrame.new(pos) end)
    end

    if S.DodgeMethod == "Jump" or S.DodgeMethod == "Both" then
        hum:ChangeState(Enum.HumanoidStateType.Jumping)
    end

    LastDodge = tick()
end

if ProjectileEvent then
    ProjectileEvent.OnClientEvent:Connect(function()
        if S.AutoDodge then
            task.spawn(function()
                task.wait(0.15)
                Dodge()
            end)
        end
    end)
end

-- ============================================================
-- AUTO TP
-- ============================================================
local LastTP   = 0
local TPTarget = nil
local TP_COOLDOWN = 0.3 -- how often TP is allowed to fire

local function AutoTP()
    if not S.AutoTP then
        TPTarget = nil
        return
    end

    local now  = tick()
    local char = LP.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return end

    -- Validate existing TP target
    if TPTarget then
        if not TPTarget.Parent or TPTarget.Health <= 0 then
            -- Target died, clear and find next immediately
            TPTarget = nil
            LastTP   = 0
        else
            local tRoot = TPTarget.Parent:FindFirstChild("HumanoidRootPart")
                       or TPTarget.Parent.PrimaryPart
            if tRoot then
                local dist = (root.Position - tRoot.Position).Magnitude
                -- Only TP if we're outside range AND cooldown passed
                if dist > S.TPRange and (now - LastTP) >= TP_COOLDOWN then
                    if not HasWall(root.Position, tRoot.Position, true) then
                        pcall(function()
                            root.CFrame = CFrame.new(tRoot.Position + Vector3.new(0, 3, 0))
                        end)
                        LastTP = now
                    end
                end
                -- Target is valid, don't search for a new one
                return
            else
                -- Target root missing, clear
                TPTarget = nil
                LastTP   = 0
            end
        end
    end

    -- No target — find the closest enemy
    UpdateCache()
    local closest = nil
    local minDist = math.huge

    for _, t in ipairs(Cache) do
        if t.hum and t.hum.Parent and t.hum.Health > 0 and not IsAlly(t.hum) then
            if (t.isPlayer and S.TargetPlayers) or (not t.isPlayer and S.TargetNPCs) then
                local dist = (root.Position - t.root.Position).Magnitude
                if dist < 300 and dist < minDist then
                    if not HasWall(root.Position, t.root.Position, true) then
                        minDist = dist
                        closest = t
                    end
                end
            end
        end
    end

    if closest and (now - LastTP) >= TP_COOLDOWN then
        TPTarget = closest.hum
        -- Only TP if target is outside range
        local dist = (root.Position - closest.root.Position).Magnitude
        if dist > S.TPRange then
            pcall(function()
                root.CFrame = CFrame.new(closest.root.Position + Vector3.new(0, 3, 0))
            end)
        end
        LastTP = now
    end
end

-- ============================================================
-- AUTO FARM
-- ============================================================
local FarmTarget = nil
local LastFarm   = 0

local function Farm()
    if not S.AutoFarm then
        FarmTarget = nil
        return
    end
    if tick() - LastFarm < 0.5 then return end

    local char = LP.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    local hum  = char and char:FindFirstChildOfClass("Humanoid")
    if not root or not hum then return end

    -- Invalidate dead/missing target
    if FarmTarget and (not FarmTarget.Parent or FarmTarget.Health <= 0) then
        FarmTarget = nil
    end

    -- Find new target
    if not FarmTarget then
        UpdateCache()
        local closest = nil
        local minDist = math.huge

        for _, t in ipairs(Cache) do
            if t.hum and t.hum.Parent and t.hum.Health > 0 and not IsAlly(t.hum) then
                local dist = (root.Position - t.root.Position).Magnitude
                if dist < S.FarmRadius and dist < minDist then
                    minDist   = dist
                    closest   = t.hum
                end
            end
        end
        FarmTarget = closest
    end

    if FarmTarget and FarmTarget.Parent then
        local tRoot = FarmTarget.Parent:FindFirstChild("HumanoidRootPart")
        if tRoot then
            local dist = (root.Position - tRoot.Position).Magnitude
            if dist > S.AuraRange - 3 then
                hum:MoveTo(tRoot.Position)
            else
                hum:Move(Vector3.zero)
            end
            if dist <= S.AuraRange then
                Attack({ hum = FarmTarget, root = tRoot })
            end
        end
    end

    LastFarm = tick()
end

-- ============================================================
-- AUTO COLLECT
-- ============================================================
local LastCollect    = 0
local CollectNames   = {"coin","gem","drop","orb","crystal","money","loot","shard"}
local MAX_COLLECT    = 5

local function Collect()
    if not S.AutoCollect then return end
    if tick() - LastCollect < 0.3 then return end

    local char = LP.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return end

    local collected = 0
    local rootPos   = root.Position

    for _, item in ipairs(WS:GetChildren()) do
        if collected >= MAX_COLLECT then break end

        local name  = item.Name:lower()
        local isCol = false

        for _, cn in ipairs(CollectNames) do
            if name:find(cn) then isCol = true; break end
        end

        if isCol then
            local pos = nil

            if item:IsA("Model") then
                local part = item.PrimaryPart or item:FindFirstChildOfClass("BasePart")
                pos = part and part.Position
            elseif item:IsA("BasePart") then
                pos = item.Position
            end

            if pos and (rootPos - pos).Magnitude <= S.CollectRadius then
                pcall(function()
                    if item:IsA("Model") and item.PrimaryPart then
                        item:SetPrimaryPartCFrame(root.CFrame)
                    elseif item:IsA("BasePart") then
                        item.CFrame = root.CFrame
                    end
                end)
                collected = collected + 1
                task.wait(S.CollectDelay)
            end
        end
    end

    LastCollect = tick()
end

-- ============================================================
-- AUTO CLAIM CODES
-- ============================================================
local Claimed = false

local function Claim()
    if Claimed then return end

    local ce = Remotes and Remotes:FindFirstChild("claimCode")
    if not ce then
        warn("[AutoClaim] claimCode remote not found.")
        return
    end

    for _, code in ipairs(Codes) do
        task.spawn(function()
            SafeInvoke(ce, code)
        end)
        task.wait(0.5)
    end

    Claimed = true
end

-- ============================================================
-- MOVEMENT
-- ============================================================
local LastMove = 0

local function ApplyMove()
    if tick() - LastMove < 0.2 then return end

    local char = LP.Character
    local hum  = char and char:FindFirstChildOfClass("Humanoid")
    if not hum then return end

    hum.WalkSpeed = S.Speed and S.WalkSpeed or 16
    hum.JumpPower = S.Jump  and S.JumpPower  or 50

    LastMove = tick()
end

-- ============================================================
-- ESP
-- ============================================================
local ESPObjs = {}

local function CreateESP(model)
    if not S.ESP or not model or not model.Parent then return end
    if ESPObjs[model] then
        -- Update color if changed
        ESPObjs[model].FillColor = S.ESPColor
        return
    end

    local h = Instance.new("Highlight")
    h.Adornee           = model
    h.FillColor         = S.ESPColor
    h.FillTransparency  = 0.5
    h.OutlineTransparency = 0
    h.Parent            = model
    ESPObjs[model]      = h
end

local function ClearESP()
    for _, esp in pairs(ESPObjs) do
        if esp and esp.Parent then esp:Destroy() end
    end
    ESPObjs = {}
end

-- Clean up ESP for dead/missing models periodically
task.spawn(function()
    while true do
        task.wait(3)
        for model, esp in pairs(ESPObjs) do
            if not model.Parent or not model:FindFirstChildOfClass("Humanoid") then
                if esp and esp.Parent then esp:Destroy() end
                ESPObjs[model] = nil
            end
        end
    end
end)

-- ============================================================
-- UI — COMBAT TAB
-- ============================================================
local Combat = Window:MakeTab({
    Name       = "Combat",
    Icon       = "rbxassetid://4483362458",
    PremiumOnly = false,
})

Combat:AddSection({ Name = "Kill Aura" })

local AuraToggle = Combat:AddToggle({
    Name    = "Kill Aura [L]",
    Default = S.KillAura,
    Save    = true,
    Flag    = "KillAura",
    Callback = function(v) S.KillAura = v end,
})

Combat:AddSlider({
    Name    = "Aura Range",
    Min     = 5,
    Max     = 100,
    Default = S.AuraRange,
    Color   = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Studs",
    Save    = true,
    Flag    = "AuraRange",
    Callback = function(v) S.AuraRange = v end,
})

Combat:AddSlider({
    Name    = "Attack Speed",
    Min     = 1,
    Max     = 100,
    Default = math.floor(S.AttackSpeed * 100),
    Color   = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "x0.01s",
    Save    = true,
    Flag    = "AttackSpeed",
    Callback = function(v) S.AttackSpeed = v / 100 end,
})

Combat:AddDropdown({
    Name    = "Priority",
    Default = S.Priority,
    Options = {"Closest", "Lowest Health", "Highest Health"},
    Save    = true,
    Flag    = "Priority",
    Callback = function(v) S.Priority = v end,
})

Combat:AddToggle({
    Name    = "Target Players",
    Default = S.TargetPlayers,
    Save    = true,
    Flag    = "TargetPlayers",
    Callback = function(v) S.TargetPlayers = v end,
})

Combat:AddToggle({
    Name    = "Target NPCs",
    Default = S.TargetNPCs,
    Save    = true,
    Flag    = "TargetNPCs",
    Callback = function(v) S.TargetNPCs = v end,
})

Combat:AddToggle({
    Name    = "Team Check",
    Default = S.TeamCheck,
    Save    = true,
    Flag    = "TeamCheck",
    Callback = function(v) S.TeamCheck = v end,
})

Combat:AddToggle({
    Name    = "Wall Check",
    Default = S.WallCheck,
    Save    = true,
    Flag    = "WallCheck",
    Callback = function(v) S.WallCheck = v end,
})

Combat:AddSection({ Name = "Boss" })

local BossToggle = Combat:AddToggle({
    Name    = "Boss Attack [B]",
    Default = S.BossAttack,
    Save    = true,
    Flag    = "BossAttack",
    Callback = function(v) S.BossAttack = v end,
})

Combat:AddDropdown({
    Name    = "Select Boss",
    Default = S.BossName,
    Options = {"Atticus", "Maneater"},
    Save    = true,
    Flag    = "BossName",
    Callback = function(v)
        S.BossName = v
        BossCache  = nil
        LastBoss   = 0
    end,
})

Combat:AddSlider({
    Name    = "Boss Speed",
    Min     = 1,
    Max     = 100,
    Default = math.floor(S.BossSpeed * 100),
    Color   = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "x0.01s",
    Save    = true,
    Flag    = "BossSpeed",
    Callback = function(v) S.BossSpeed = v / 100 end,
})

Combat:AddSection({ Name = "Dodge" })

local DodgeToggle = Combat:AddToggle({
    Name    = "Auto Dodge [N]",
    Default = S.AutoDodge,
    Save    = true,
    Flag    = "AutoDodge",
    Callback = function(v) S.AutoDodge = v end,
})

Combat:AddDropdown({
    Name    = "Dodge Method",
    Default = S.DodgeMethod,
    Options = {"Teleport", "Jump", "Both"},
    Save    = true,
    Flag    = "DodgeMethod",
    Callback = function(v) S.DodgeMethod = v end,
})

-- ============================================================
-- UI — MOVEMENT TAB
-- ============================================================
local Move = Window:MakeTab({
    Name       = "Movement",
    Icon       = "rbxassetid://4483362458",
    PremiumOnly = false,
})

Move:AddSection({ Name = "Speed" })

local SpeedToggle = Move:AddToggle({
    Name    = "Speed [K]",
    Default = S.Speed,
    Save    = true,
    Flag    = "Speed",
    Callback = function(v) S.Speed = v ApplyMove() end,
})

Move:AddSlider({
    Name    = "Walk Speed",
    Min     = 16,
    Max     = 250,
    Default = S.WalkSpeed,
    Color   = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Speed",
    Save    = true,
    Flag    = "WalkSpeed",
    Callback = function(v) S.WalkSpeed = v ApplyMove() end,
})

Move:AddSection({ Name = "Jump" })

Move:AddToggle({
    Name    = "Jump Boost",
    Default = S.Jump,
    Save    = true,
    Flag    = "Jump",
    Callback = function(v) S.Jump = v ApplyMove() end,
})

Move:AddSlider({
    Name    = "Jump Power",
    Min     = 50,
    Max     = 300,
    Default = S.JumpPower,
    Color   = Color3.fromRGB(255, 255, 255),
    Increment = 5,
    ValueName = "Power",
    Save    = true,
    Flag    = "JumpPower",
    Callback = function(v) S.JumpPower = v ApplyMove() end,
})

Move:AddSection({ Name = "Auto TP" })

local AutoTPToggle = Move:AddToggle({
    Name    = "Auto TP [T]",
    Default = S.AutoTP,
    Save    = true,
    Flag    = "AutoTP",
    Callback = function(v) S.AutoTP = v end,
})

Move:AddSlider({
    Name    = "TP Range",
    Min     = 10,
    Max     = 100,
    Default = S.TPRange,
    Color   = Color3.fromRGB(255, 255, 255),
    Increment = 5,
    ValueName = "Studs",
    Save    = true,
    Flag    = "TPRange",
    Callback = function(v) S.TPRange = v end,
})

Move:AddToggle({
    Name    = "TP Wall Check",
    Default = S.TPWallCheck,
    Save    = true,
    Flag    = "TPWallCheck",
    Callback = function(v) S.TPWallCheck = v end,
})

-- ============================================================
-- UI — FARM TAB
-- ============================================================
local FarmTab = Window:MakeTab({
    Name       = "Farm",
    Icon       = "rbxassetid://4483362458",
    PremiumOnly = false,
})

FarmTab:AddSection({ Name = "Auto Farm" })

local FarmToggle = FarmTab:AddToggle({
    Name    = "Auto Farm [J]",
    Default = S.AutoFarm,
    Save    = true,
    Flag    = "AutoFarm",
    Callback = function(v) S.AutoFarm = v end,
})

FarmTab:AddSlider({
    Name    = "Farm Radius",
    Min     = 10,
    Max     = 200,
    Default = S.FarmRadius,
    Color   = Color3.fromRGB(255, 255, 255),
    Increment = 5,
    ValueName = "Studs",
    Save    = true,
    Flag    = "FarmRadius",
    Callback = function(v) S.FarmRadius = v end,
})

FarmTab:AddSection({ Name = "Auto Collect" })

local CollectToggle = FarmTab:AddToggle({
    Name    = "Auto Collect [H]",
    Default = S.AutoCollect,
    Save    = true,
    Flag    = "AutoCollect",
    Callback = function(v) S.AutoCollect = v end,
})

FarmTab:AddSlider({
    Name    = "Collect Radius",
    Min     = 10,
    Max     = 200,
    Default = S.CollectRadius,
    Color   = Color3.fromRGB(255, 255, 255),
    Increment = 5,
    ValueName = "Studs",
    Save    = true,
    Flag    = "CollectRadius",
    Callback = function(v) S.CollectRadius = v end,
})

-- ============================================================
-- UI — VISUAL TAB
-- ============================================================
local Visual = Window:MakeTab({
    Name       = "Visual",
    Icon       = "rbxassetid://4483362458",
    PremiumOnly = false,
})

Visual:AddSection({ Name = "ESP" })

Visual:AddToggle({
    Name    = "ESP",
    Default = S.ESP,
    Save    = true,
    Flag    = "ESP",
    Callback = function(v)
        S.ESP = v
        if not v then ClearESP() end
    end,
})

Visual:AddColorpicker({
    Name    = "ESP Color",
    Default = S.ESPColor,
    Flag    = "ESPColor",
    Callback = function(v)
        S.ESPColor = v
        for _, esp in pairs(ESPObjs) do
            if esp and esp.Parent then
                esp.FillColor = v
            end
        end
    end,
})

-- ============================================================
-- UI — SETTINGS TAB
-- ============================================================
local Settings = Window:MakeTab({
    Name       = "Settings",
    Icon       = "rbxassetid://4483362458",
    PremiumOnly = false,
})

Settings:AddSection({ Name = "Webhook" })

Settings:AddToggle({
    Name    = "Enable Webhook",
    Default = S.WebhookEnabled,
    Save    = true,
    Flag    = "WebhookEnabled",
    Callback = function(v) S.WebhookEnabled = v end,
})

Settings:AddTextbox({
    Name        = "Webhook URL",
    Default     = S.WebhookURL,
    TextDisappear = false,
    Flag        = "WebhookURL",
    Callback    = function(v) S.WebhookURL = v end,
})

Settings:AddButton({
    Name = "Test Webhook",
    Callback = function()
        local ok = SendWebhook("Test Notification", "Webhook is working!", 3447003)
        OrionLib:MakeNotification({
            Name     = "Webhook Test",
            Content  = ok and "Successfully sent!" or "Failed - Check your URL",
            Image    = "rbxassetid://4483362458",
            Time     = 3,
        })
    end,
})

Settings:AddSection({ Name = "Codes" })

Settings:AddButton({
    Name = "Claim All Codes",
    Callback = function()
        Claimed = false
        Claim()
        OrionLib:MakeNotification({
            Name    = "Codes",
            Content = "Claiming all codes...",
            Image   = "rbxassetid://4483362458",
            Time    = 3,
        })
    end,
})

Settings:AddToggle({
    Name    = "Auto Claim on Start",
    Default = S.AutoClaim,
    Save    = true,
    Flag    = "AutoClaim",
    Callback = function(v) S.AutoClaim = v end,
})

Settings:AddSection({ Name = "Misc" })

Settings:AddToggle({
    Name    = "Auto Respawn",
    Default = S.AutoRespawn,
    Save    = true,
    Flag    = "AutoRespawn",
    Callback = function(v) S.AutoRespawn = v end,
})

Settings:AddButton({
    Name = "Reset All",
    Callback = function()
        S.KillAura    = false; AuraToggle:Set(false)
        S.BossAttack  = false; BossToggle:Set(false)
        S.AutoFarm    = false; FarmToggle:Set(false)
        S.AutoCollect = false; CollectToggle:Set(false)
        S.Speed       = false; SpeedToggle:Set(false)
        S.AutoTP      = false; AutoTPToggle:Set(false)
        S.AutoDodge   = false; DodgeToggle:Set(false)
        ApplyMove()
        OrionLib:MakeNotification({
            Name    = "Reset",
            Content = "All features disabled.",
            Image   = "rbxassetid://4483362458",
            Time    = 2,
        })
    end,
})

-- ============================================================
-- KEYBINDS
-- ============================================================
UIS.InputBegan:Connect(function(i, g)
    if g then return end

    if i.KeyCode == Enum.KeyCode.L then
        S.KillAura = not S.KillAura
        AuraToggle:Set(S.KillAura)

    elseif i.KeyCode == Enum.KeyCode.K then
        S.Speed = not S.Speed
        SpeedToggle:Set(S.Speed)
        ApplyMove()

    elseif i.KeyCode == Enum.KeyCode.J then
        S.AutoFarm = not S.AutoFarm
        FarmToggle:Set(S.AutoFarm)

    elseif i.KeyCode == Enum.KeyCode.H then
        S.AutoCollect = not S.AutoCollect
        CollectToggle:Set(S.AutoCollect)

    elseif i.KeyCode == Enum.KeyCode.B then
        S.BossAttack = not S.BossAttack
        BossToggle:Set(S.BossAttack)

    elseif i.KeyCode == Enum.KeyCode.N then
        S.AutoDodge = not S.AutoDodge
        DodgeToggle:Set(S.AutoDodge)

    elseif i.KeyCode == Enum.KeyCode.T then
        S.AutoTP = not S.AutoTP
        AutoTPToggle:Set(S.AutoTP)
    end
end)

-- ============================================================
-- MAIN LOOPS (all wrapped in task.spawn with error recovery)
-- ============================================================

-- Kill Aura loop
task.spawn(function()
    while true do
        local ok, err = pcall(function()
            if S.KillAura then
                UpdateCache()
                local t = GetTarget()
                if t then
                    Attack(t)
                    if S.ESP then CreateESP(t.model) end
                end
            end
        end)
        if not ok then warn("[KillAura] " .. tostring(err)) end
        task.wait(math.max(S.AttackSpeed, 0.03))
    end
end)

-- Boss Attack loop
task.spawn(function()
    while true do
        local ok, err = pcall(function()
            if S.BossAttack then
                local b = GetBoss()
                if b then Attack(b, b.dmg) end
            end
        end)
        if not ok then warn("[BossAttack] " .. tostring(err)) end
        task.wait(math.max(S.BossSpeed, 0.03))
    end
end)

-- Auto Farm loop
task.spawn(function()
    while true do
        local ok, err = pcall(function()
            if S.AutoFarm then
                UpdateCache()
                Farm()
            end
        end)
        if not ok then warn("[AutoFarm] " .. tostring(err)) end
        task.wait(0.7)
    end
end)

-- Auto Collect loop
task.spawn(function()
    while true do
        local ok, err = pcall(function()
            if S.AutoCollect then
                Collect()
            end
        end)
        if not ok then warn("[AutoCollect] " .. tostring(err)) end
        task.wait(0.4)
    end
end)

-- Auto TP loop
task.spawn(function()
    while true do
        local ok, err = pcall(function()
            if S.AutoTP then
                UpdateCache()
                AutoTP()
            end
        end)
        if not ok then warn("[AutoTP] " .. tostring(err)) end
        task.wait(0.1) -- tight loop, cooldown handled internally
    end
end)

-- Movement loop
task.spawn(function()
    while true do
        local ok, err = pcall(function()
            if S.Speed or S.Jump then
                ApplyMove()
            end
        end)
        if not ok then warn("[Movement] " .. tostring(err)) end
        task.wait(0.3)
    end
end)

-- ============================================================
-- RESPAWN HANDLER
-- ============================================================
LP.CharacterAdded:Connect(function()
    task.wait(1)

    -- Reset cached targets on respawn
    FarmTarget = nil
    TPTarget   = nil
    BossCache  = nil

    ApplyMove()

    if S.AutoRespawn then
        OrionLib:MakeNotification({
            Name    = "Respawned",
            Content = "Character loaded - features active.",
            Image   = "rbxassetid://4483362458",
            Time    = 2,
        })
    end
end)

-- ============================================================
-- INIT
-- ============================================================
OrionLib:Init()

if S.AutoClaim then
    task.delay(2, Claim)
end

task.delay(1, function()
    WebhookNotify("ScriptStarted", {})
end)

OrionLib:MakeNotification({
    Name    = "Pixel Blade v3.0",
    Content = "L=Aura  K=Speed  J=Farm  H=Collect  B=Boss  N=Dodge  T=TP",
    Image   = "rbxassetid://4483362458",
    Time    = 6,
})

print("[PixelBlade v3.0] Loaded successfully.")
print("[Keys] L=Aura | K=Speed | J=Farm | H=Collect | B=Boss | N=Dodge | T=TP")
